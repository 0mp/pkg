.\" Copyright (c) 1990, 1991, 1993
.\"     The Regents of the University of California.  All rights reserved.
.\" Copyright (c) 2013 Matthew Seaman <matthew@FreeBSD.org>
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Chris Torek and the American National Standards Committee X3,
.\" on Information Processing Systems.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.Dd January 26, 2013
.Dt PKG_PRINTF 3
.Os
.Sh NAME
.Nm pkg_printf , pkg_fprintf , pkg_dprintf , pkg_snprintf , pkg_asprintf ,
.Nm pkg_sbuf_printf , pkg_sbuf_vprintf
.Nd formatted output of package data
.Sh LIBRARY
.Lb libpkg
.Sh SYNOPSIS
.In pkg.h
.Ft int
.Fn pkg_printf "const char * restrict format" ...
.Ft int
.Fn pkg_fprintf "FILE * restrict stream" "const char * restrict format" ...
.Ft int
.Fn pkg_dprintf "int fd" "const char * restrict format" ...
.Ft int
.Fn pkg_snprintf "char * restrict str" "size_t size" "const char * restrict format" ...
.Ft int
.Fn pkg_asprintf "char **ret" "const char * restrict format" ...
.Ft struct sbuf *
.Fn pkg_sbuf_printf "struct sbuf * restrict sbuf" "const char * restrict format" ...
.Ft struct sbuf *
.Fn pkg_sbuf_vprintf "struct sbuf * restrict sbuf" "const char * restrict format" "va_list ap"
.Sh DESCRIPTION
The
.Fn pkg_printf
family of functions produces output of package data according to a
.Fa format
as described below, analogously to the similarly named
.Xr printf 3
family of functions.
The
.Fn pkg_printf
function
writes output to
.Dv stdout ,
the standard output stream;
.Fn pkg_fprintf
writes output to the given output
.Fa stream ;
.Fn pkg_dprintf
writes output to the given file descriptor;
.Fn pkg_snprintf ,
writes to the character string
.Fa str ;
.Fn pkg_asprintf
dynamically allocates a new string with
.Xr malloc 3 ;
.Fn pkg_sbuf_printf
and
.Fn pkg_sbuf_vprintf
write to the given sbuf structure.
.Pp
These functions write the output under the control of a
.Fa format
string that specifies how subsequent arguments
(or arguments accessed via the variable-length argument facilities of
.Xr stdarg 3 )
are converted for output.
.Pp
These functions return the number of characters printed
(not including the trailing
.Ql \e0
used to end output to strings) or a negative value if an output error occurs,
except for
.Fn pkg_snprintf
which returns the number of characters that would have been printed if the
.Fa size
were unlimited
(again, not including the final
.Ql \e0 ) 
and the two functions
.Fn pkg_sbuf_printf
and
.Fn pkg_sbuf_vprintf
which return the given sbuf pointer, or
.Dv NULL
in the case of errors. 
.Pp
The
.Fn pkg_asprintf
function
sets
.Fa *ret
to be a pointer to a buffer sufficiently large to hold the formatted string.
This pointer should be passed to
.Xr free 3
to release the allocated storage when it is no longer needed.
If sufficient space cannot be allocated,
.Fn pkg_asprintf
will return \-1 and set
.Fa ret
to be a
.Dv NULL
pointer.
.Pp
The
.Fn pkg_snprintf
function
will write at most
.Fa size Ns \-1
of the characters printed into the output string
(the
.Fa size Ns 'th
character then gets the terminating
.Ql \e0 ) ;
if the return value is greater than or equal to the
.Fa size
argument, the string was too short
and some of the printed characters were discarded.
The output is always null-terminated.
.Pp
The format string is composed of zero or more directives:
ordinary
.\" multibyte
characters (not
.Cm % ) ,
which are copied unchanged to the output stream;
and conversion specifications, each of which results
in fetching zero or more subsequent arguments.
Each conversion specification is introduced by
the
.Cm %
character.
The arguments must correspond properly with the conversion specifier.
After the
.Cm % ,
the following appear in sequence:
.Bl -bullet
.It
Zero or more of the following flags:
.Bl -tag -width ".So \  Sc (space)"
.It Cm ?
The value should be converted to the
.Dq first alternate form .
For integer valued conversions
.Cm ( I , s
and
.Cm t )
this is a
.Vt humanized
form as a floating point value scaled to the range 0 \- 1000
followed by the SI powers-of-10 scale factor.
See
.Sx SCALE FACTORS .
For array valued conversions
.Cm ( B , C , D , F , G , L , O , U , d ,
and
.Cm r )
generate
.Dq 0
if there are no items in the array,
.Dq 1
otherwise.
For formats returning file modes
.Cm ( Dp
or
.Cm Fp )
print the mode in the style of
.Xr strmode 3 .
For boolean valued formats
.Cm ( Dk , \^Dt , Fk , a
and
.Cm k )
generate either
.Dq yes
or
.Dq no .
.It Cm #
The value should be converted to the
.Dq second alternate form .
For the integer valued conversions
.Cm ( I , s , t  )
this is a
.Dq humanized
form as a floating point value scaled to the range 0 \- 1024
followed by the IEE/IEC and SI powers-of-2 scale factor.
See
.Sx SCALE FACTORS .
For array valued conversions
.Cm ( B , C , D , F , G , L , O , U , d ,
and
.Cm r )
generate the number of items in the array.
For formats returning file modes
.Cm ( Dp
or
.Cm Fp )
print the mode as an octal integer with a leading 0.
For boolean valued formats
.Cm ( Dk , \^Dt , Fk , a
and
.Cm k )
generate either
.Dq true
or
.Dq false .
.It Cm 0 (zero)
Zero padding.
For all integer valued conversions and humanized numbers the converted
value is padded on the left with zeros rather than blanks.
Applies to
.Cm ( I , s ,
and
.Cm t )
.It Cm \-
A negative field width flag;
the converted value is to be left adjusted on the field boundary.
The converted value is padded on the right with blanks,
rather than on the left with blanks or zeros.
Applies to all scalar-valued conversions.
.Cm \-
overrides a
.Cm 0
if both are given.
.It So "\ " Sc (space)
A blank should be left before a positive number
produced by a signed conversion
.Cm ( I , s ,
or
.Cm t ) .
.It Cm +
A sign must always be placed before a
number produced by a signed conversion.
A
.Cm +
overrides a space if both are used.
.It Sq Cm '
Numerical conversions
.Cm ( I , s ,
or
.Cm t )
should be grouped and separated by thousands using
the non-monetary separator returned by
.Xr localeconv 3 .
.El
.It
An optional decimal digit string specifying a minimum field width.
If the converted value has fewer characters than the field width,
it will be padded with spaces (or zeroes, if the zero-padding flag has
been given and the conversion supports it) on the left (or spaces on
the right, if the left-adjustment flag has been given) to fill out the
field width.
.It
One or two characters that specifies the type of conversion to be applied.
.It
A
.Dq row format
for array valued conversions
.Cm ( B , C , D , F , G , L , O , U , d ,
and
.Cm r ) .
The row format is one or two strings containing any number of the format
conversions described here, bracketed by the character sequences
.Cm %{
and
.Cm %}
and optionally divided into two by the character sequence
.Cm %| .
The first or only format string is repeatedly processed for each of the
array items in turn.
The optional second format string is processed as a separator between
each of the array items.
Which conversion characters are permissible in the row format is
context dependent.
See the 
.Sx FORMAT CODES
section for details.
.El
.Ss SCALE FACTORS
Humanized number conversions (using the scale the number to lie within
the range 1 \- 1000 (power of ten conversions using the
.Cm ?
format modifier) or 1 \- 1024 (power of two conversions using the
.Cm #
format modifier) and append a scale factor as follows:
.Pp
The SI power of ten suffixes are
.Bl -column "Suffix" "Description" "1,000,000,000,000,000,000" -offset indent
.It Sy "Suffix" Ta Sy "Description" Ta Sy "Multiplier"
.It Li \^ Ta No (none) Ta 1
.It Li k Ta No kilo   Ta 1,000
.It Li M Ta No mega   Ta 1,000,000
.It Li G Ta No giga   Ta 1,000,000,000
.It Li T Ta No tera   Ta 1,000,000,000,000
.It Li P Ta No peta   Ta 1,000,000,000,000,000
.It Li E Ta No exa    Ta 1,000,000,000,000,000,000
.El
.Pp
The IEE/IEC (and now also SI) power of two suffixes are:
.Bl -column "Suffix" "Description" "1,000,000,000,000,000,000" -offset indent
.It Sy "Suffix" Ta Sy "Description" Ta Sy "Multiplier"
.It Li \^ Ta No (none) Ta 1
.It Li Ki Ta No kibi   Ta 1,024
.It Li Mi Ta No mebi   Ta 1,048,576
.It Li Gi Ta No gibi   Ta 1,073,741,824
.It Li Ti Ta No tebi   Ta 1,099,511,627,776
.It Li Pi Ta No pebi   Ta 1,125,899,906,842,624
.It Li Ei Ta No exbi   Ta 1,152,921,504,606,846,976
.El
.Pp
.Ss FORMAT CODES
.Pp
The conversion specifiers and their meanings are:
.Bl -tag -width ".Cm Bn"
.It Cm B
Shared libraries [array]
.Vt struct pkg *
.It Cm Bn
Shared library name [string]
.Vt struct pkg_shlib *
.It Cm C
Categories [array]
.Vt struct pkg *
.It Cm Cn
Category name [string]
.Vt struct pkg_category *
.It Cm D
Directories [array]
.Vt struct pkg *
.It Cm Dg
Directory ownership: group name [string]
.Vt struct pkg_dir *
.It Cm Dk
Directory keep flag [boolean]
.Vt struct pkg_dir *
.It Cm Dn
Directory path name [string]
.Vt struct pkg_dir *
.It Cm Dp
Directory permissions [mode]
.Vt struct pkg_dir *
.It Cm \^Dt
Directory try flag [boolean]
.Vt struct pkg_dir *
.It Cm Du
Directory ownership: user name [string]
.Vt struct pkg_dir *
.It Cm F
Files [array]
.Vt struct pkg *
.It Cm Fg
File ownership: group name [string]
.Vt struct pkg_file *
.It Cm Fk
File keep flag [boolean]
.Vt struct pkg_file *
.It Cm \^Fn
File path name [string]
.Vt struct pkg_file *
.It Cm Fp
File permissions [mode]
.Vt struct pkg_file *
.It Cm Fs
File SHA256 checksum [string]
.Vt struct pkg_file *
.It Cm Fu
File ownership: user name [string]
.Vt struct pkg_file *
.It Cm G
Groups [array]
.Vt struct pkg *
.It Cm Gg
Group GID-string [string]
.Vt struct pkg_group *
.It Cm Gn
Group name [string]
.Vt struct pkg_group *
.It Cm I
Row counter [integer]
.It Cm L
Licenses [array]
.Vt struct pkg *
.It Cm Ln
Licence name [string]
.Vt struct pkg_license *
.It Cm M
Package message [string]
.Vt struct pkg *
.It Cm O
Options [array]
.Vt struct pkg *
.It Cm On
Option name [string]
.Vt struct pkg_option *
.It Cm Ov
Option value [string]
.Vt struct pkg_option *
.It Cm U
Users [array]
.Vt struct pkg *
.It Cm Un
User name [string]
.Vt struct pkg_user *
.It Cm Uu
User UID-str [string]
.Vt struct pkg_user *
.It Cm a
Autoremove flag [boolean]
.Vt struct pkg *
.It Cm c
Comment [string]
.Vt struct pkg *
.It Cm d
Dependencies [array]
.Vt struct pkg *
.It Cm dn
Dependency name [string]
.Vt struct pkg_dep *
.It Cm do
Dependency origin [string]
.Vt struct pkg_dep *
.It Cm dv
Dependency version [string]
.Vt struct pkg_dep *
.It Cm i
Additional information [string]
.Vt struct pkg *
.It Cm k
Locking status [boolean]
.Vt struct pkg *
.It Cm l
License logic [licence-logic type]
.Vt struct pkg *
.It Cm m
Maintainer [string]
.Vt struct pkg *
.It Cm n
Package name [string]
.Vt struct pkg *
.It Cm o
Origin [string]
.Vt struct pkg *
.It Cm p
Prefix [string]
.Vt struct pkg *
.It Cm r
Requirements [array]
.Vt struct pkg *
.It Cm rn
Requirement name [string]
.Vt struct pkg_dep *
.It Cm ro
Requirement origin [string]
.Vt struct pkg_dep *
.It Cm rv
Requirement version [string]
.Vt struct pkg_dep *
.It Cm s
Package flat size [integer]
.Vt struct pkg *
.It Cm t
Installation timestamp [date-time]
.Vt struct pkg *
.It Cm v
Package version [string]
.Vt struct pkg *
.It Cm w
Home page URL [string]
.Vt struct pkg *
.It Cm %
A
.Ql %
is written.
No argument is converted.
The complete conversion specification
is
.Ql %% .
.El
.Pp
The decimal point
character is defined in the program's locale (category
.Dv LC_NUMERIC ) .
.Pp
In no case does a non-existent or small field width cause truncation of
a numeric field; if the result of a conversion is wider than the field
width, the
field is expanded to contain the conversion result.
.Sh EXAMPLES
To print a date and time in the form
.Dq Li "Sunday, July 3, 10:02" ,
where
.Fa weekday
and
.Fa month
are pointers to strings:
.Bd -literal -offset indent
#include <stdio.h>
fprintf(stdout, "%s, %s %d, %.2d:%.2d\en",
	weekday, month, day, hour, min);
.Ed
.Pp
To print \*(Pi
to five decimal places:
.Bd -literal -offset indent
#include <math.h>
#include <stdio.h>
fprintf(stdout, "pi = %.5f\en", 4 * atan(1.0));
.Ed
.Pp
To allocate a 128 byte string and print into it:
.Bd -literal -offset indent
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
char *newfmt(const char *fmt, ...)
{
	char *p;
	va_list ap;
	if ((p = malloc(128)) == NULL)
		return (NULL);
	va_start(ap, fmt);
	(void) vsnprintf(p, 128, fmt, ap);
	va_end(ap);
	return (p);
}
.Ed
.Sh ERRORS
In addition to the errors documented for the
.Xr write 2
system call, the
.Fn pkg_printf
family of functions may fail if:
.Bl -tag -width Er
.It Bq Er EILSEQ
An invalid wide character code was encountered.
.It Bq Er ENOMEM
Insufficient storage space is available.
.El
.Sh SEE ALSO
.Xr printf 1 ,
.Xr printf 3 ,
.Xr strftime 3 ,
.Xr setlocale 3
.Sh BUGS
The
.Nm pkg_printf
family of functions do not correctly handle multibyte characters in the
.Fa format
argument.
.Sh SECURITY CONSIDERATIONS
Equivalents to the
.Fn sprintf
and
.Fn vsprintf
functions are not supplied.
Instead, use
.Fn pkg_snprintf
to write into a fixed length buffer without danger of overflow.
.Pp
The
.Fn pkg_printf
family, like the
.Fn printf
family of functions it is modelled on, is also easily misused in a manner
allowing malicious users to arbitrarily change a running program's
functionality by either causing the program
to print potentially sensitive data
.Dq "left on the stack" ,
or causing it to generate a memory fault or bus error
by dereferencing an invalid pointer.
.Pp
Programmers are therefore strongly advised to never pass untrusted strings
as the
.Fa format
argument, as an attacker can put format specifiers in the string
to mangle your stack,
leading to a possible security hole.
This holds true even if the string was built using a function like
.Fn snprintf ,
as the resulting string may still contain user-supplied conversion specifiers
for later interpolation by
.Fn pkg_printf .
.Pp
Always use the proper secure idiom:
.Pp
.Dl "pkg_snprintf(buffer, sizeof(buffer), \*q%s\*q, string);"
